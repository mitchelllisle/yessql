{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to YesSQL Caution This library is still in active development and is subject to change until we reach a stable version. Please report any bugs/issues/ideas or features to our GitHub repo What is YesSQL? YesSQL is a Python database library that simplifies the way you connect to and interact with common SQL databases. Why do we need another database library? There are already some fantastic database libraries out there for Python. However I have always been disappointed by the amount of boiler plate that you have to write before you can start working with data. This library aims to address a number of challenges in working with common SQL databases: Philosophy Reduce the amount of time and code I need to write before I can start working with my data Provide a common format and syntax for different databases Let me model my data and provide you the model so I know the data I'm getting is what I expect Provide me with async and non-async options These are the principles I have adopted when writing this library. We try and keep a small footprint of dependencies. The main libraries we use are: Dependencies Pydantic: An excellent data validation and modelling library aiomysql: An Async MySQL library asyncpg: An async Postgres library pg8000: A non-async Postgres library Just show me some code Here is an example of the minimum you need to do before being able to access your data: Reading data import asyncio from yessql import AioPostgres , PostgresConfig # (1) async def main (): config = PostgresConfig ( host = \"localhost\" , username = \"my_username\" , password = \"my_password\" , database = \"my_database\" ) async with AioPostgres ( config ) as pg : async for row in pg . read ( \"SELECT * FROM table\" ): print ( row ) if __name__ == '__main__' : asyncio . run ( main ()) Writing Data import asyncio from yessql import AioPostgres , PostgresConfig # (1) async def main (): config = PostgresConfig ( host = \"localhost\" , username = \"my_username\" , password = \"my_password\" , database = \"my_database\" ) async with AioPostgres ( config ) as pg : await pg . write ( stmt = \"INSERT INTO table (id, name) VALUES ($1, $2)\" , params = [( \"1\" , \"john\" ), ( \"2\" , \"paul\" )] ) if __name__ == '__main__' : asyncio . run ( main ()) You can easily swap out the Postgres variants for MySQL or omit Aio for non-async variants Check out the examples page for more detail","title":"Home"},{"location":"#welcome-to-yessql","text":"Caution This library is still in active development and is subject to change until we reach a stable version. Please report any bugs/issues/ideas or features to our GitHub repo","title":"Welcome to YesSQL"},{"location":"#what-is-yessql","text":"YesSQL is a Python database library that simplifies the way you connect to and interact with common SQL databases.","title":"What is YesSQL?"},{"location":"#why-do-we-need-another-database-library","text":"There are already some fantastic database libraries out there for Python. However I have always been disappointed by the amount of boiler plate that you have to write before you can start working with data. This library aims to address a number of challenges in working with common SQL databases: Philosophy Reduce the amount of time and code I need to write before I can start working with my data Provide a common format and syntax for different databases Let me model my data and provide you the model so I know the data I'm getting is what I expect Provide me with async and non-async options These are the principles I have adopted when writing this library. We try and keep a small footprint of dependencies. The main libraries we use are: Dependencies Pydantic: An excellent data validation and modelling library aiomysql: An Async MySQL library asyncpg: An async Postgres library pg8000: A non-async Postgres library","title":"Why do we need another database library?"},{"location":"#just-show-me-some-code","text":"Here is an example of the minimum you need to do before being able to access your data: Reading data import asyncio from yessql import AioPostgres , PostgresConfig # (1) async def main (): config = PostgresConfig ( host = \"localhost\" , username = \"my_username\" , password = \"my_password\" , database = \"my_database\" ) async with AioPostgres ( config ) as pg : async for row in pg . read ( \"SELECT * FROM table\" ): print ( row ) if __name__ == '__main__' : asyncio . run ( main ()) Writing Data import asyncio from yessql import AioPostgres , PostgresConfig # (1) async def main (): config = PostgresConfig ( host = \"localhost\" , username = \"my_username\" , password = \"my_password\" , database = \"my_database\" ) async with AioPostgres ( config ) as pg : await pg . write ( stmt = \"INSERT INTO table (id, name) VALUES ($1, $2)\" , params = [( \"1\" , \"john\" ), ( \"2\" , \"paul\" )] ) if __name__ == '__main__' : asyncio . run ( main ()) You can easily swap out the Postgres variants for MySQL or omit Aio for non-async variants Check out the examples page for more detail","title":"Just show me some code"},{"location":"contributing/","text":"Contributing Coming soon...","title":"Contributing"},{"location":"contributing/#contributing","text":"Coming soon...","title":"Contributing"},{"location":"usage/","text":"Usage Creating a database config object Reading data using the async generator method read Reading all results using read_all Creating a database config object There are three config objects provided for connecting to a database. We use Pydantic's BaseSettings for this since it already has excellent functionality for reading values from the environment as well as being able to override them or provide defaults when necessary. DatabaseConfig : A parent class providing common fields such as host, port, username and password MySQLConfig : A MySQL specific config PostgresConfig : A Postgres specific config Note The following examples will all use the Postgres variants of the library. All examples will work for MySQL as well. Simply import the MySQL objects instead. Sourcing config values from the environment Assuming you have an environment with the following variables export HOST = localhost export USER = admin export PASSWORD = admin export DATABASE = yessql Then, creating a config object is as simple as from yessql import PostgresConfig config = PostgresConfig () # (1) This config object provides a default port of 5432 but can be overridden by your environment if necessary You can also provide values directly from yessql import PostgresConfig config = PostgresConfig ( host = \"127.0.0.1\" ) Or extend them with more information from yessql import PostgresConfig class MyPGConfig ( PostgresConfig ): table : str config = MyPGConfig ( table = \"my_table\" ) Reading data using the async generator method read When reading data from a database you often will query for large datasets. Loading an entire table or query results into memory is not ideal. For these situations the read method is useful as it is an async generator. This means we yield each row one at a time without loading everything into memory. import asyncio from yessql import AioPostgres , PostgresConfig async def main (): config = PostgresConfig ( database = \"my_database\" ) async with AioPostgres ( config ) as pg : async for row in pg . read ( \"SELECT * FROM table\" ): print ( row ) if __name__ == '__main__' : asyncio . run ( main ()) Reading all results using read_all In cases where there isn't alot of data, or you need everything in memory to do some processing on an entire query set / table - you can use the read_all method which will return a list of rows. import asyncio from typing import List , Dict from yessql import AioPostgres , PostgresConfig async def main () -> List [ Dict ]: config = PostgresConfig ( database = \"my_database\" ) async with AioPostgres ( config ) as pg : data = pg . read_all ( \"SELECT * FROM table\" ) return data if __name__ == '__main__' : asyncio . run ( main ())","title":"Usage"},{"location":"usage/#usage","text":"Creating a database config object Reading data using the async generator method read Reading all results using read_all","title":"Usage"},{"location":"usage/#creating-a-database-config-object","text":"There are three config objects provided for connecting to a database. We use Pydantic's BaseSettings for this since it already has excellent functionality for reading values from the environment as well as being able to override them or provide defaults when necessary. DatabaseConfig : A parent class providing common fields such as host, port, username and password MySQLConfig : A MySQL specific config PostgresConfig : A Postgres specific config Note The following examples will all use the Postgres variants of the library. All examples will work for MySQL as well. Simply import the MySQL objects instead.","title":"Creating a database config object"},{"location":"usage/#sourcing-config-values-from-the-environment","text":"Assuming you have an environment with the following variables export HOST = localhost export USER = admin export PASSWORD = admin export DATABASE = yessql Then, creating a config object is as simple as from yessql import PostgresConfig config = PostgresConfig () # (1) This config object provides a default port of 5432 but can be overridden by your environment if necessary You can also provide values directly from yessql import PostgresConfig config = PostgresConfig ( host = \"127.0.0.1\" ) Or extend them with more information from yessql import PostgresConfig class MyPGConfig ( PostgresConfig ): table : str config = MyPGConfig ( table = \"my_table\" )","title":"Sourcing config values from the environment"},{"location":"usage/#reading-data-using-the-async-generator-method-read","text":"When reading data from a database you often will query for large datasets. Loading an entire table or query results into memory is not ideal. For these situations the read method is useful as it is an async generator. This means we yield each row one at a time without loading everything into memory. import asyncio from yessql import AioPostgres , PostgresConfig async def main (): config = PostgresConfig ( database = \"my_database\" ) async with AioPostgres ( config ) as pg : async for row in pg . read ( \"SELECT * FROM table\" ): print ( row ) if __name__ == '__main__' : asyncio . run ( main ())","title":"Reading data using the async generator method read"},{"location":"usage/#reading-all-results-using-read_all","text":"In cases where there isn't alot of data, or you need everything in memory to do some processing on an entire query set / table - you can use the read_all method which will return a list of rows. import asyncio from typing import List , Dict from yessql import AioPostgres , PostgresConfig async def main () -> List [ Dict ]: config = PostgresConfig ( database = \"my_database\" ) async with AioPostgres ( config ) as pg : data = pg . read_all ( \"SELECT * FROM table\" ) return data if __name__ == '__main__' : asyncio . run ( main ())","title":"Reading all results using read_all"},{"location":"docs/SUMMARY/","text":"Yessql aiomysql aiopostgres client params clients config postgres utils","title":"SUMMARY"},{"location":"docs/yessql/aiomysql/","text":"AioMySQL Bases: AsyncDatabaseClient , ABC close_pool () async Close Connection Pool Close the connection pool. If you're running this class inside a context manager (which you should be) then this will get called as part of exiting the context. Returns: Type Description None None commit ( stmt ) async Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required read ( query , params = None , model = None ) async Read results from postgres and return an AsyncGenerator. This allows you to read large amounts of data without having to store them in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Tuple Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel we'll use as the row return type None Returns: Type Description AsyncGenerator An AsyncGenerator setup_pool () async Setup Connection Pool We use connection pools for connecting to MySQL. This method can be used to set up the connection - however you will need to call close_pool to ensure all database connections are correctly closed when no longer needed. Although some situations may require you to do these steps manually, you should (where possible) use the context manager aspect of this class (I.E. using a with statement) since this will handle closing the connection for you. Returns: Type Description Nothing is returned. This will instead initialise the pool property. write ( stmt , params ) async Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params Union [ Tuple , str , int ] The data to pass as params required Returns: Type Description None None","title":"aiomysql"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL","text":"Bases: AsyncDatabaseClient , ABC","title":"AioMySQL"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL.close_pool","text":"Close Connection Pool Close the connection pool. If you're running this class inside a context manager (which you should be) then this will get called as part of exiting the context. Returns: Type Description None None","title":"close_pool()"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL.commit","text":"Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required","title":"commit()"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL.read","text":"Read results from postgres and return an AsyncGenerator. This allows you to read large amounts of data without having to store them in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Tuple Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel we'll use as the row return type None Returns: Type Description AsyncGenerator An AsyncGenerator","title":"read()"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL.setup_pool","text":"Setup Connection Pool We use connection pools for connecting to MySQL. This method can be used to set up the connection - however you will need to call close_pool to ensure all database connections are correctly closed when no longer needed. Although some situations may require you to do these steps manually, you should (where possible) use the context manager aspect of this class (I.E. using a with statement) since this will handle closing the connection for you. Returns: Type Description Nothing is returned. This will instead initialise the pool property.","title":"setup_pool()"},{"location":"docs/yessql/aiomysql/#yessql.aiomysql.AioMySQL.write","text":"Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params Union [ Tuple , str , int ] The data to pass as params required Returns: Type Description None None","title":"write()"},{"location":"docs/yessql/clients/","text":"AsyncDatabaseClient Bases: ABC commit ( stmt ) abstractmethod async Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required read ( query , params = None , model = None ) abstractmethod async Read results from postgres and return an AsyncGenerator. This allows you to read large amounts of data without having to store them in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Dict Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel that each row will be parsed to None Returns: Type Description AsyncGenerator An AsyncGenerator read_all ( query , params = None , model = None ) async In some cases you might want to just return the data without dealing with iteration you can use this. We'll return all the records in a list. Be careful using this for large datasets as it will try and load everything in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Dict Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel we'll use as the row return type None Returns: Type Description Union [ List [ Dict ], Type [ BaseModel ]] A List of Records write ( stmt , params ) abstractmethod async Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params Tuple The data to pass as params required Returns: Type Description None None writer ( stmt ) return a writer for the given statement. Basically just curry's the write method into a coroutine that accepts a batch of parameters and writes using the given statement. Obviously this is useful if you are batching inserts. Parameters: Name Type Description Default stmt str The Insert statement you want to run required","title":"clients"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient","text":"Bases: ABC","title":"AsyncDatabaseClient"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient.commit","text":"Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required","title":"commit()"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient.read","text":"Read results from postgres and return an AsyncGenerator. This allows you to read large amounts of data without having to store them in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Dict Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel that each row will be parsed to None Returns: Type Description AsyncGenerator An AsyncGenerator","title":"read()"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient.read_all","text":"In some cases you might want to just return the data without dealing with iteration you can use this. We'll return all the records in a list. Be careful using this for large datasets as it will try and load everything in memory. Parameters: Name Type Description Default query str The query you want to return data for required params Dict Any params you need to pass to the query None model Type [ BaseModel ] An optional pydantic.BaseModel we'll use as the row return type None Returns: Type Description Union [ List [ Dict ], Type [ BaseModel ]] A List of Records","title":"read_all()"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient.write","text":"Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params Tuple The data to pass as params required Returns: Type Description None None","title":"write()"},{"location":"docs/yessql/clients/#yessql.clients.AsyncDatabaseClient.writer","text":"return a writer for the given statement. Basically just curry's the write method into a coroutine that accepts a batch of parameters and writes using the given statement. Obviously this is useful if you are batching inserts. Parameters: Name Type Description Default stmt str The Insert statement you want to run required","title":"writer()"},{"location":"docs/yessql/config/","text":"DatabaseConfig Bases: BaseSettings Config object for connecting to databases. This is a generic config object that can be subclassed to create database specific config and extended to include specific functionality or defaults relevant to that database technology. Notes You probably want to import and use database specific configs such as MySQLConfig and PostgresConfig. This is simply a parent class with common config. Attributes: Name Type Description host SecretStr The host name to connect to port int The port to use for connections user SecretStr The username to authenticate with password SecretStr The password to authenticate with MySQLConfig Bases: DatabaseConfig Attributes: Name Type Description host The host name to connect to port int The port to use for connections user int The username to authenticate with password int The password to authenticate with db int Optional attribute for the database to connect to","title":"config"},{"location":"docs/yessql/config/#yessql.config.DatabaseConfig","text":"Bases: BaseSettings Config object for connecting to databases. This is a generic config object that can be subclassed to create database specific config and extended to include specific functionality or defaults relevant to that database technology. Notes You probably want to import and use database specific configs such as MySQLConfig and PostgresConfig. This is simply a parent class with common config. Attributes: Name Type Description host SecretStr The host name to connect to port int The port to use for connections user SecretStr The username to authenticate with password SecretStr The password to authenticate with","title":"DatabaseConfig"},{"location":"docs/yessql/config/#yessql.config.MySQLConfig","text":"Bases: DatabaseConfig Attributes: Name Type Description host The host name to connect to port int The port to use for connections user int The username to authenticate with password int The password to authenticate with db int Optional attribute for the database to connect to","title":"MySQLConfig"},{"location":"docs/yessql/postgres/","text":"ContextCursor Bases: postgresql . Cursor ContextCursor For some reason cursors always require you to define an explicit connect and close. This turns these operations into a context manager to make it safer and ensure the cursor is closed after use. Postgres Blocking Postgres Client Synchronous Postgres client for interacting with Postgres databases. For Asynchronous Postgres client see yessql.AioPostgres __init__ ( config ) Parameters: Name Type Description Default config PostgresConfig A PostgresConfig object for connecting to the database required close_connection () Close the connection to the database. Can be used explicitly or will be called as you exit out of a context managed statement. Returns: Type Description None None commit ( stmt ) Although mostly the same as the write method - commit is useful for identifying when you are making changes to the database and not pass params. Use this for any CREATE, DROP etc. statements where you are managing the database to indicate to other developers where you are changing the database VS writing data to it Parameters: Name Type Description Default stmt str The statement to run required Returns: Type Description int Row count read ( query , params = None ) Read data from the database using the given query and params. This is a generator meaning you can iterate through the rows without loading them all into memory. Parameters: Name Type Description Default query str The query to run required params Tuple Any params to be substituted for %s strings in above query None Returns: Type Description Generator A generator read_all ( query , params = None ) If you want to return all rows from the query without worrying about memory management then this method is useful. It will return a list of dictionaries containing the results of the query Parameters: Name Type Description Default query str The query to run required params Tuple Any params to be substituted for %s strings in above query None Returns: Type Description List [ Dict ] A list of dicts with the data from the query setup_connection () Make a call to the database and attempt to set up a connection. This can either be called explicitly or will be called as part of a context statement (I.e. using with ) Returns: Type Description None None write ( stmt , rows ) Write some data to the database by passing an insert statement and a list of tuples for the rows Parameters: Name Type Description Default stmt str The insert statement to run. %s placeholders are used for indicating params required rows List [ Tuple ] A list of tuples containing the data to pass to the above query. required Returns: Type Description int Row count as an integer","title":"postgres"},{"location":"docs/yessql/postgres/#yessql.postgres.ContextCursor","text":"Bases: postgresql . Cursor ContextCursor For some reason cursors always require you to define an explicit connect and close. This turns these operations into a context manager to make it safer and ensure the cursor is closed after use.","title":"ContextCursor"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres","text":"Blocking Postgres Client Synchronous Postgres client for interacting with Postgres databases. For Asynchronous Postgres client see yessql.AioPostgres","title":"Postgres"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.__init__","text":"Parameters: Name Type Description Default config PostgresConfig A PostgresConfig object for connecting to the database required","title":"__init__()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.close_connection","text":"Close the connection to the database. Can be used explicitly or will be called as you exit out of a context managed statement. Returns: Type Description None None","title":"close_connection()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.commit","text":"Although mostly the same as the write method - commit is useful for identifying when you are making changes to the database and not pass params. Use this for any CREATE, DROP etc. statements where you are managing the database to indicate to other developers where you are changing the database VS writing data to it Parameters: Name Type Description Default stmt str The statement to run required Returns: Type Description int Row count","title":"commit()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.read","text":"Read data from the database using the given query and params. This is a generator meaning you can iterate through the rows without loading them all into memory. Parameters: Name Type Description Default query str The query to run required params Tuple Any params to be substituted for %s strings in above query None Returns: Type Description Generator A generator","title":"read()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.read_all","text":"If you want to return all rows from the query without worrying about memory management then this method is useful. It will return a list of dictionaries containing the results of the query Parameters: Name Type Description Default query str The query to run required params Tuple Any params to be substituted for %s strings in above query None Returns: Type Description List [ Dict ] A list of dicts with the data from the query","title":"read_all()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.setup_connection","text":"Make a call to the database and attempt to set up a connection. This can either be called explicitly or will be called as part of a context statement (I.e. using with ) Returns: Type Description None None","title":"setup_connection()"},{"location":"docs/yessql/postgres/#yessql.postgres.Postgres.write","text":"Write some data to the database by passing an insert statement and a list of tuples for the rows Parameters: Name Type Description Default stmt str The insert statement to run. %s placeholders are used for indicating params required rows List [ Tuple ] A list of tuples containing the data to pass to the above query. required Returns: Type Description int Row count as an integer","title":"write()"},{"location":"docs/yessql/utils/","text":"PendingConnection Pending Connection Class This class is used to differentiate between having made an actual connection to the database vs only having instantiated the class. This is important so that we can catch any confusing errors and instead return more helpful messages explaining that a connection has not been made yet. PendingConnectionError Bases: ValueError Error for when you attempt to use connection before calling setup_connection","title":"utils"},{"location":"docs/yessql/utils/#yessql.utils.PendingConnection","text":"Pending Connection Class This class is used to differentiate between having made an actual connection to the database vs only having instantiated the class. This is important so that we can catch any confusing errors and instead return more helpful messages explaining that a connection has not been made yet.","title":"PendingConnection"},{"location":"docs/yessql/utils/#yessql.utils.PendingConnectionError","text":"Bases: ValueError Error for when you attempt to use connection before calling setup_connection","title":"PendingConnectionError"},{"location":"docs/yessql/aiopostgres/client/","text":"AioPostgres Bases: AsyncDatabaseClient __init__ ( config , timeout = None , min_size = 1 , max_size = 10 ) AioPostgres is an async postgres client that allows you to set up a connection pool for Postgres and read and write data asynchronously. Contains an async context manager for easy setup and closing of the connections that you open. Parameters: Name Type Description Default config PostgresConfig a DatabaseConfig object that contains all the connection details for postgres required timeout int max time before a query is cancelled None min_size int The minimum # of connections that will be reserved for this client 1 max_size int The maximum # of connections that will be reserved for this client 10 close_pool () async Close Connection Pool Close the connection pool. If you're running this class inside a context manager (which you should be) then this will get called as part of exiting the context. Returns: Type Description None None commit ( stmt ) async Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required write ( stmt , params ) async Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params List [ Dict ] The data to pass as params required Returns: Type Description None None","title":"client"},{"location":"docs/yessql/aiopostgres/client/#yessql.aiopostgres.client.AioPostgres","text":"Bases: AsyncDatabaseClient","title":"AioPostgres"},{"location":"docs/yessql/aiopostgres/client/#yessql.aiopostgres.client.AioPostgres.__init__","text":"AioPostgres is an async postgres client that allows you to set up a connection pool for Postgres and read and write data asynchronously. Contains an async context manager for easy setup and closing of the connections that you open. Parameters: Name Type Description Default config PostgresConfig a DatabaseConfig object that contains all the connection details for postgres required timeout int max time before a query is cancelled None min_size int The minimum # of connections that will be reserved for this client 1 max_size int The maximum # of connections that will be reserved for this client 10","title":"__init__()"},{"location":"docs/yessql/aiopostgres/client/#yessql.aiopostgres.client.AioPostgres.close_pool","text":"Close Connection Pool Close the connection pool. If you're running this class inside a context manager (which you should be) then this will get called as part of exiting the context. Returns: Type Description None None","title":"close_pool()"},{"location":"docs/yessql/aiopostgres/client/#yessql.aiopostgres.client.AioPostgres.commit","text":"Run a command against the database. This is useful for statements where you need to change the database in some way E.g. ALTER, CREATE, DROP statements etc. Parameters: Name Type Description Default stmt str The statement to run required","title":"commit()"},{"location":"docs/yessql/aiopostgres/client/#yessql.aiopostgres.client.AioPostgres.write","text":"Write data to a table with the given statement and data Parameters: Name Type Description Default stmt str The Insert statement you want to run required params List [ Dict ] The data to pass as params required Returns: Type Description None None","title":"write()"},{"location":"docs/yessql/aiopostgres/params/","text":"","title":"params"}]}